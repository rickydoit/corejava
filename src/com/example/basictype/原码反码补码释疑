一、计算机中为什么用补码？

先来看二进制减法：2-3 在计算机中是如何运算的
 2的二进制（0）0010
          |-- 括号中的0是符号位，为什么符号位用0表示正数1表示负数，后面会推导。
-3的二进制（1）0011

2-3=2+（-3）  （0）0010
             （1）0011
              ----------
             （1）0101
（1）0101 换算成十进制是 -6，显然在计算机中用二进制原码计算负数时出错了。

这里引入模的概念，为了直观不妨拿我们熟悉的时钟来举例。
模就像是一个计量系统的计数范围，实质上是计量系统产生“溢出”的量，它的值在计量器上表示不出来，计量器上只能表示出模的余数。
如时钟只能表示0~11点的数值，12则是该时钟的模，当值大于等于12时，则需要对时钟的模(12)进行取余运算，得到该计量系统的值。

时钟一圈是12小时，可以看成是十二进制，那么2点钟-3点钟要怎么算呢？
对于2点，我们理解为从12点顺时针走2个小时；那么2点钟-3点钟理解为从2点点的位置再逆时针走3个小时，恰好落在顺时针的11点上。

关键的一步：2点-3点是否能等价于 2点+9点的？
也就是说时针从2点钟逆时针拨3小时，是不是等价于2点钟向顺时针拨9小时，很明显最终结果都是拨到11点上。
所以，在十二进制的时钟里，逆时针拨3小时等价于顺时针拨9小时，它们相加刚好是12，也就是走了一整圈。

理解了上面的内容，我们就可以定义补码了。正数的补码就是它本身，负数的补码就是取最大计算容量减负数的绝对值。
在本列中就是 3和9是互补的。

上面基本上解决了加法问题，接下来解决符号位问题。

假设a为正数，b为负数,模为d，b'是b的补数。
如果|a|>|b|,则 |a|>d - |b'|，即 |a|+|b'|>d 越界，进一位，符号为从1变为0 结果为正数
如果|a|<|b|,则 |a|<d - |b'|，即 |a|+|b'|<d 不越界不进位，符号还是1 结果为负数
这里刚好解释了为何负数的符号位要取（1）的原因

  2的二进制（0）0010 ，补码为 （0）0010
 -3的二进制（0）0011 ，补码为 （1）1101

补码运算（0）0010 + （1）1101 = （1）1111，这是补码运算的结果，还需要再变回原码才是我们想要的最
终结果。（1）1111的原码就是再取一次补码，原码是（1）0001 ，也就是负数-1，即十进制中 2-3 =-1。

通过对补码的理解，也就清楚了java中byte的取值范围为何是 127~ -128之间了。因为第1位是符号位，后面7位才是数值位。
以（0）开头的为 0~127，以（1）开头的为 -1~-128 。正是因为计算机只有加法器才导致了数据以补码的形式进行计算的，计算机可以
做减法器，但是实现起来比加法器麻烦，故前人们设计了这种最简单最有效率的计算方式。